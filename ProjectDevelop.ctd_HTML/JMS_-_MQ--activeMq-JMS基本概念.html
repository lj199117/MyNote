<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>activeMq-JMS基本概念</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="webull工作.html">webull工作</a></p>

<p><a href="Maven.html">Maven</a></p>

<ol>
<li><a href="Maven--distributionManagement.html">distributionManagement</a></li>
</ol>
<p><a href="架构相关.html">架构相关</a></p>

<ol>
<li><a href="架构相关--关于dubbo.html">关于dubbo</a></li>
<li><a href="架构相关--POM结构图.html">POM结构图</a></li>
<li><a href="架构相关--dbuuo基础架构.html">dbuuo基础架构</a></li>
</ol>
<p><a href="zk的配置与部署.html">zk的配置与部署</a></p>

<p><a href="linux.html">linux</a></p>

<ol>
<li><a href="linux--linux的Java环境配置.html">linux的Java环境配置</a></li>
<li><a href="linux--服务器远程拷贝.html">服务器远程拷贝</a></li>
<li><a href="linux--linux_系统相关常用.html">linux 系统相关常用</a></li>
</ol>
<p><a href="月总结.html">月总结</a></p>

<ol>
<li><a href="月总结--18-02(md5_mysql相关).html">18-02(md5 mysql相关)</a></li>
<li><a href="月总结--18-03-07(一个项目是如何run的).html">18-03-07(一个项目是如何run的)</a></li>
<li><a href="月总结--18-03-08(自我评价).html">18-03-08(自我评价)</a></li>
<li><a href="月总结--18-03-09(maven).html">18-03-09(maven)</a></li>
<li><a href="月总结--18-03-20_xml.html">18-03-20 xml</a></li>
<li><a href="月总结--18-03-22_app.xml各节点解析.html">18-03-22 app.xml各节点解析</a></li>
<li><a href="月总结--18-04-01_Spring_父子容器.html">18-04-01 Spring 父子容器</a></li>
</ol>
<p><a href="快速调试方法.html">快速调试方法</a></p>

<ol>
<li><a href="快速调试方法--log.html">log</a></li>
<li><a href="快速调试方法--debug远程项目.html">debug远程项目</a></li>
<li><a href="快速调试方法--项目实施异常解决过程.html">项目实施异常解决过程</a></li>
</ol>
<p><a href="git.html">git</a></p>

<p><a href="redis.html">redis</a></p>

<ol>
<li><a href="redis--redis的安装与主从复制.html">redis的安装与主从复制</a></li>
<li><a href="redis--Redis集群搭建与简单使用.html">Redis集群搭建与简单使用</a></li>
<li><a href="redis--redis操作.html">redis操作</a></li>
</ol>
<p><a href="AOP--Filter使用，过滤器和拦截器的区别.html">AOP--Filter使用，过滤器和拦截器的区别</a></p>

<p><a href="VM分析.html">VM分析</a></p>

<ol>
<li><a href="VM分析--死锁分析.html">死锁分析</a></li>
<li><a href="VM分析--jstack排查定位线程.html">jstack排查定位线程</a></li>
<li><a href="VM分析--jmap,jhat,jstat,hprof使用和分析.html">jmap,jhat,jstat,hprof使用和分析</a></li>
</ol>
<p><a href="JMS_-_MQ.html">JMS - MQ</a></p>

<ol>
<li><a href="JMS_-_MQ--消息队列基本知识.html">消息队列基本知识</a></li>
<li><a href="JMS_-_MQ--kafak安装与使用.html">kafak安装与使用</a></li>
<li><a href="JMS_-_MQ--kafka集群模式.html">kafka集群模式</a></li>
<li><a href="JMS_-_MQ--kafka-webull.html">kafka-webull</a></li>
<li><a href="JMS_-_MQ--activeMq-JMS基本概念.html">activeMq-JMS基本概念</a></li>
<li><a href="JMS_-_MQ--activeMq-MessageListenerContainer.html">activeMq-MessageListenerContainer</a></li>
<li><a href="JMS_-_MQ--activeMq-三种消息监听器.html">activeMq-三种消息监听器</a></li>
<li><a href="JMS_-_MQ--AMQ可靠消息传送.html">AMQ可靠消息传送</a></li>
<li><a href="JMS_-_MQ--activeMq在项目中基本使用.html">activeMq在项目中基本使用</a></li>
</ol>
<p><a href="高并发.html">高并发</a></p>

<p><a href="mysql数据库设计开发最佳实践.html">mysql数据库设计开发最佳实践</a></p>

<ol>
<li><a href="mysql数据库设计开发最佳实践--存储过程.html">存储过程</a></li>
<li><a href="mysql数据库设计开发最佳实践--mysql知识总结.html">mysql知识总结</a></li>
</ol></div>
<div class="page"><h1><b><u>activeMq-JMS基本概念</u></b></h1>1<span style="color:#3f3f3f;">基本概念</span><br />JMS（JAVA Message Service,java消息服务）API是一个<span style="color:#f30404;">消息服务的标准或者说是规范</span>，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。<span style="color:#3f3f3f;">JMS是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。</span><br /><br />2<span style="color:#3f3f3f;">消息模型</span><br /><span style="color:#3f3f3f;">点对点P2P和发布订阅模型Pub/Sub</span><br /><br />3<span style="color:#3f3f3f;">点对点P2P</span><br />P2P的特点<br />• 每个消息都被发送到一个特定的队列，接收者从队列中获取消息。<span style="color:#f30404;">队列保留着消息，直到他们被消费或超时。</span><br />• 每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)<br />• 发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列<br />• <span style="color:#f30404;">接收者在成功接收消息之后需向队列应答成功</span><br />如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。<br /><br />4发布订阅模型Pub/Sub<br />Pub/Sub的特点<br />• 每个消息可以有多个消费者<br />• 发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。<br />• 为了缓和这样严格的时间相关性，<span style="color:#f30404;">JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</span><br />如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型<br /><br /><br /><span style="background-color:#f9f720;">5</span><span style="color:#3f3f3f;background-color:#f9f720;">JMS编程模型</span><br />• ConnectionFactory<br /><span style="color:#f30404;">创建Connection对象的工厂，针对两种不同的jms消息模型</span>，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。<br />• Destination<br />Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息<span style="color:#f30404;">生产者来说，它的Destination是某个队列（Queue extends Destination）或某个主题（Topic extends Destination）</span>;对于消息<span style="color:#f30404;">消费者来说，它的Destination也是某个队列或主题</span>（即消息来源）。<br />所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。<br />• Connection<br />Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。<br />• Session<br /><span style="color:#f30404;">Session是我们操作消息的接口</span>。可以通过session创建生产者、消费者、消息等。<span style="color:#f30404;background-color:#f9f720;">Session提供了事务的功能</span>。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。<br /><img src="images\28-1.png" alt="images\28-1.png" /><br />• 消息的生产者<br /><span style="color:#f30404;">消息生产者由Session创建</span>（messageProducer = session.createProducer(queue);），并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender（extends MessageProducer）和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。<br />• 消息消费者<br /><span style="color:#f30404;">消息消费者由Session创建</span>（messageConsumer = session.createConsumer(queue);），用于接收被发送到Destination的消息。两种类型：QueueReceiver（extends MessageConsumer）和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。<br />• MessageListener<br />消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener。<br /><br /></div></div>
</body></html>