<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>18-03-09(maven)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="webull工作.html">webull工作</a></p>

<p><a href="Maven.html">Maven</a></p>

<ol>
<li><a href="Maven--distributionManagement.html">distributionManagement</a></li>
</ol>
<p><a href="架构相关.html">架构相关</a></p>

<ol>
<li><a href="架构相关--关于dubbo.html">关于dubbo</a></li>
<li><a href="架构相关--POM结构图.html">POM结构图</a></li>
<li><a href="架构相关--dbuuo基础架构.html">dbuuo基础架构</a></li>
</ol>
<p><a href="zk的配置与部署.html">zk的配置与部署</a></p>

<p><a href="linux.html">linux</a></p>

<ol>
<li><a href="linux--linux的Java环境配置.html">linux的Java环境配置</a></li>
<li><a href="linux--服务器远程拷贝.html">服务器远程拷贝</a></li>
<li><a href="linux--linux_系统相关常用.html">linux 系统相关常用</a></li>
</ol>
<p><a href="月总结.html">月总结</a></p>

<ol>
<li><a href="月总结--18-02(md5_mysql相关).html">18-02(md5 mysql相关)</a></li>
<li><a href="月总结--18-03-07(一个项目是如何run的).html">18-03-07(一个项目是如何run的)</a></li>
<li><a href="月总结--18-03-08(自我评价).html">18-03-08(自我评价)</a></li>
<li><a href="月总结--18-03-09(maven).html">18-03-09(maven)</a></li>
<li><a href="月总结--18-03-20_xml.html">18-03-20 xml</a></li>
<li><a href="月总结--18-03-22_app.xml各节点解析.html">18-03-22 app.xml各节点解析</a></li>
<li><a href="月总结--18-04-01_Spring_父子容器.html">18-04-01 Spring 父子容器</a></li>
</ol>
<p><a href="快速调试方法.html">快速调试方法</a></p>

<ol>
<li><a href="快速调试方法--log.html">log</a></li>
<li><a href="快速调试方法--debug远程项目.html">debug远程项目</a></li>
<li><a href="快速调试方法--项目实施异常解决过程.html">项目实施异常解决过程</a></li>
</ol>
<p><a href="git.html">git</a></p>

<p><a href="redis.html">redis</a></p>

<ol>
<li><a href="redis--redis的安装与主从复制.html">redis的安装与主从复制</a></li>
<li><a href="redis--Redis集群搭建与简单使用.html">Redis集群搭建与简单使用</a></li>
<li><a href="redis--redis操作.html">redis操作</a></li>
</ol>
<p><a href="AOP--Filter使用，过滤器和拦截器的区别.html">AOP--Filter使用，过滤器和拦截器的区别</a></p>

<p><a href="VM分析.html">VM分析</a></p>

<ol>
<li><a href="VM分析--死锁分析.html">死锁分析</a></li>
<li><a href="VM分析--jstack排查定位线程.html">jstack排查定位线程</a></li>
<li><a href="VM分析--jmap,jhat,jstat,hprof使用和分析.html">jmap,jhat,jstat,hprof使用和分析</a></li>
</ol>
<p><a href="JMS_-_MQ.html">JMS - MQ</a></p>

<ol>
<li><a href="JMS_-_MQ--消息队列基本知识.html">消息队列基本知识</a></li>
<li><a href="JMS_-_MQ--kafak安装与使用.html">kafak安装与使用</a></li>
<li><a href="JMS_-_MQ--kafka集群模式.html">kafka集群模式</a></li>
<li><a href="JMS_-_MQ--kafka-webull.html">kafka-webull</a></li>
<li><a href="JMS_-_MQ--activeMq-JMS基本概念.html">activeMq-JMS基本概念</a></li>
<li><a href="JMS_-_MQ--activeMq-MessageListenerContainer.html">activeMq-MessageListenerContainer</a></li>
<li><a href="JMS_-_MQ--activeMq-三种消息监听器.html">activeMq-三种消息监听器</a></li>
<li><a href="JMS_-_MQ--AMQ可靠消息传送.html">AMQ可靠消息传送</a></li>
<li><a href="JMS_-_MQ--activeMq在项目中基本使用.html">activeMq在项目中基本使用</a></li>
</ol>
<p><a href="高并发.html">高并发</a></p>

<p><a href="mysql数据库设计开发最佳实践.html">mysql数据库设计开发最佳实践</a></p>

<ol>
<li><a href="mysql数据库设计开发最佳实践--存储过程.html">存储过程</a></li>
<li><a href="mysql数据库设计开发最佳实践--mysql知识总结.html">mysql知识总结</a></li>
</ol></div>
<div class="page"><h1><b><u>18-03-09(maven)</u></b></h1><span style="background-color:#f9f720;">注意一定要从</span><span style="color:#f30404;background-color:#f9f720;">大-&gt;小</span><span style="background-color:#f9f720;">进行分析</span><br /><br />xml<br /><br />maven : maven权威指南 1-6章<br />maven总结：<a href="http://www.cnblogs.com/chrischennx/p/5119627.html">http://www.cnblogs.com/chrischennx/p/5119627.html</a><br /><br />spring4.x ; app.xml  各个标签节点的意思<br /><br /><br />maven:<br />• Ⅰ 介绍MAVEN<br />1. maven是什么？干什么？<br />☐ Maven是一个项目管理工具，构建工具，减轻维护第三方依赖的负担；我觉得，<span style="color:#ff0000;">Maven的核心功能便是合理叙述项目间的依赖关系</span>，通俗点讲，就是通过<span style="color:#ff0000;">pom.xml</span>文件的配置获取jar包，而不用手动去添加jar包<br />☐ POM的主要内容是处理描述信息：哪里存放源代码？哪里存放资源文件？打包方式是什么；<br />2. 约定优于配置<br />    在maven中，没有自定义的情况下，目录一般如下，<br />    •     源代码是在 /myApp/src/main/java，<br />    •     资源文件是在 /myApp/src/main/resources，<br />    •     测试代码是在 /myApp/src/test ；<br />    项目会产生一个 JAR 文件。Maven会把<br />    •     编译好的字节码放到 /myApp/target/classes<br />    并且<br />    •     创建的可分发JAR 文件放在 /myApp/target<br />3. 基于maven插件的全局重用性<br />Maven 的核心其实不做什么实际的事情，<span style="color:#f30404;">Maven大部分的智能是由插件实现的</span>，而插件从 Maven 仓库获得。Maven 从远程仓库获取依赖和插件的这一事实允许了构建逻辑的全局性重用。<br />举个例子，以单元测试为例，本来你工程的单元测试是基于junit3写的，本来的运行单元测试的插件版本(Maven Surefire)只能执行junit3，后来出了junit4，果断的你换成了支持注解的junit4，那么问题来了，原来版本的Maven Surefire不支持了，需要升级新版本，常规的做法是升级插件，各种麻烦，使用maven之后，只需要在POM中修改一下版本号，就是这么简单。<br /><br />• Ⅱ安装与运行<br />1. 没啥好说的，下载，配置环境变量，settings.xml，eclipse user-setting<br /><br />总结：<br />前两章主要是介绍性的工作，可以分为下面几个点进行总结；<br />1.maven是什么？有什么用？：官方说是项目对象模型，对项目进行管理，构建等工作；大白话应该<span style="color:#ff0000;">Maven的核心功能便是合理叙述项目间的依赖关系</span>，通俗点讲，就是通过<span style="color:#ff0000;">pom.xml</span>文件的配置获取jar包，而不用手动去添加jar包<br />2.maven里面有个概念：约定优于配置，比如约定源代码、资源文件、测试代码的目录位置；好处就是规范化，maven install可以一键启动...，这一点在maven的生命周期也有体现<br />3.maven的实现：单就maven而言，它自己没干任何事，都是由maven插件贡献的，所以有全局重用性<br /><br /><span style="color:#f30404;">----------------------------------------------------------------    分割线，前两章是maven介绍性工作      ------------------------------------------------</span><br /><br /><br />• ⅢMaven项目实战+核心概念<br />1. <span style="color:#f30404;">创建</span>一个简单项目(<span style="background-color:#f9f720;">这个项目是maven上的例子代码</span>)<br />archetype ：插件名称 generate ：插件目标(方法)  -DgroupId=xx ：插件参数列表<br /><div class="codebox"><div class="codebox">mvn&nbsp;archetype<span style="color:#ff9d00;font-weight:700">:</span>generate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">#plugin&nbsp;name&nbsp;:&nbsp;plugin&nbsp;goal&nbsp;</span><br />-DgroupId=org.sonatype.mavenbook.ch03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0088ff;font-weight:400">#&nbsp;plugin&nbsp;params</span><br />-DartifactId=simple&nbsp;<br />-DpackageName=org.sonatype.mavenbook<br /><br />简记为：<br />插件名称<span style="color:#ff9d00;font-weight:700">:</span>插件目标&nbsp;-插件参数</div></div><br />生成如下目录结构：<br /><img src="images\43-1.png" alt="images\43-1.png" /><br />2. <span style="color:#f30404;">构建</span>一个简单项目<br />在包括pom.xml下的执行<br />    清除产生的项目：mvn clean <br />    打包：mvn package   <br />    在本地Repository中安装jar：mvn install <br />    <br />用java <span style="color:#f30404;">run起来</span><br />    <span style="color:#f30404;">java -cp</span> target/simple-1.0-SNAPSHOT.jar org.sonatype.mavenbook.ch03.App  注：-cp = -classpath <br /><br />3. 简单的pom.xml介绍<br />暴露Maven的默认设置<br /><div class="codebox"><div class="codebox">mvn&nbsp;help<span style="color:#ff9d00;font-weight:700">:</span>effective-pom</div></div><br /><br />核心概念<br />1. maven插件与目标<br />☐ 当提到一个插件目标的时候，我们常常用速记符号：pluginId:goalId。例如，当提到<span style="color:#f30404;">Archetype插件</span>的<span style="color:#f30404;">create目标</span>的时候，我们写成archetype:create。<br />☐ Maven的核心对你项目构建中特定的任务几乎毫无所知。就<span style="color:#f30404;">它本身来说，Maven不知道如何编译你的代码，它甚至不知道如何制作一个JAR文件</span>，它把所有这些<span style="color:#f30404;background-color:#f9f720;">任务代理给了Maven插件</span>。<br />2. Maven生命周期<br />☐ mvn package命令并<span style="color:#f30404;">没有指定一个插件目标</span>，而是指定了一个Maven生命周期阶段，每个<span style="color:#f30404;">阶段可能绑定了零个或者多个目标</span>。所以：<br />    mvn package (<span style="color:#ff0000;">-Dmaven.test.skip</span>=<span style="color:#0000ff;">true</span>)<br />        <span style="color:#f30404;">相当于执行</span>下列插件与目标<br />    mvn resources:resources \<br />        compiler:compile \<br />        resources:testResources \<br />        compiler:testCompile \<br />        surefire:test \<br />        jar:jar<br />        <img src="images\43-2.png" alt="images\43-2.png" /><br />3. Maven坐标<br />☐ groupId, artifactId, version和packaging。它们可以用来唯一标识一个项目，一个依赖，或者Maven POM里的一个插件<br />4. Maven仓库<br />当你第一次运行Maven的时候，你会注意到Maven从一个远程的Maven仓库下载了许多构件/插件。<br />Maven自带了一个用来下载Maven核心插件和依赖的远程仓库地址（<a href="http://repo1.maven.org/maven2）。">http://repo1.maven.org/maven2</a>）<br />☐ 一个Maven仓库是项目构件的一个集合(<span style="color:#f30404;">可以理解为一个存储文件的文件系统</span>)；相对于仓库的根目录（依然是<a href="http://repo1.maven.org/maven2）。">http://repo1.maven.org/maven2</a>），这些构件以Maven坐标为基础的目录格式来存储构件。<br />☐ 本地仓库、第三方仓库、中央仓库<br />5. Maven依赖管理<br />一个复杂的项目将会包含很多依赖，maven可以解决依赖中的<span style="color:#f30404;">传递性依赖问题和冲突性依赖问题</span><br />☐ <span style="color:#f30404;">传递性依赖的实现</span>是基于Maven下载构件的同时会下载构件对应的POM文件来寻找传递性依赖；项目A依赖于项目B和C，项目B依赖于项目D，项目C依赖于项目E，但是项目A所需要做的只是定义对B和C的依赖<br />☐ Maven的依赖范围(scope: test, provided, import)<br />    test 只有在插件运行test目标的时候生效； <br />    provided可以排除war文件中的特定依赖，它可以告诉maven只有在编译的时候需要该jar，但是我打包出来的WEB-INF/lib下不需要该jar;<br /><br /><br />• Ⅳ如何定制一个Maven项目<br />1. 老套路，先创建项目，使用mvn archetype:generate<br />2. 定制项目信息，在dependencies元素之前添加licenses，organization 和 developers 元素 + 添加所需依赖(如xml解析的jar)<br />3. 编写代码<br />4. running : <br />☐ 运行java：<span style="color:#f30404;">mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main</span>  | 可以通过<span style="color:#f30404;background-color:#f9f720;">mvn help:describe -Dplugin=exec -Dfull查看插件的使用方式</span>，之前也说过，再比如<span style="color:#f30404;background-color:#f9f720;">mvn help:describe -Dplugin=archetype -Dfull</span><br />☐ 浏览依赖：<span style="color:#f30404;">mvn dependency:resolve</span><br /><img src="images\43-3.png" alt="images\43-3.png" /><br />☐ 单元测试：<br />    <span style="color:#f30404;">忽略失败的测试：mvn test -</span><span style="color:#f30404;background-color:#f9f720;">Dmaven.test.failure.ignore=true</span><span style="color:#f30404;">  </span>或者配置pom  maven-surefire-plugin <span style="color:#f30404;">&lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;<br />    跳过单元测试：mvn install/test -</span><span style="color:#f30404;background-color:#f9f720;">Dmaven.test.skip=true</span> 或者配置pom maven-surefire-plugin <span style="color:#f30404;">&lt;skip&gt;true&lt;/skip&gt;</span><br />☐ 构建打包：maven-assembly-plugin插件 <a href="https://www.cnblogs.com/f-zhao/p/6929814.html">https://www.cnblogs.com/f-zhao/p/6929814.html</a><br /><br /><br /><br />• Ⅴ简单web项目<br />1. 老套路，先创建项目，注意这是不是archetype:simple那种类型了,我们需要一个webapp项目，所以<span style="color:#f30404;">DarchetypeArtifactId=</span><span style="color:#f30404;background-color:#f9f720;">maven-archetype-webapp</span><br /><div class="codebox"><div class="codebox">mvn&nbsp;archetype<span style="color:#ff9d00;font-weight:700">:</span>generate&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;-DgroupId=org.sonatype.mavenbook.ch05<br />&nbsp;&nbsp;&nbsp;&nbsp;-DartifactId=simple-webapp&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;-DpackageName=org.sonatype.mavenbook&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;-DarchetypeArtifactId=maven-archetype-webapp<br /></div></div><br /><br />2. 部署到servlet容器：jetty<br />☐ 需要在项目的 pom.xml 中配置 Maven Jetty 插件<br />☐ 启动应用：mvn jetty:run<br />☐ 访问<a href="http://">http://</a>localhost:8080/simple-webapp/<br /><br />3. 我要添加一个servlet：编写servlet类 -&gt; web.xml 配置servlet+mapping -&gt; pom.xml添加java2e依赖<br /><br /><br />• Ⅵ多模块项目<br />☐ &lt;parent&gt; &amp; &lt;modules&gt; 典型的我们公司的结构<br />☐ 当Maven执行mvn clean install 一个带有子模块的项目的时候，<span style="color:#f30404;">Maven首先载入父POM</span>，然后定位所有的子模块POM。Maven然后将所有这些项目的POM<span style="color:#f30404;">放入到一个称为Maven 反应堆</span>（Reactor）的东西中，由<span style="color:#f30404;">它负责分析模块之间的依赖关系</span>。这个反应堆处理组件的排序，以确保相互独立的模块能以适当的顺序被编译和安装。然后，<span style="color:#f30404;">所有的子模块分别执行了mvn clean install </span><br /><br />• Ⅶ多模块企业级项目<br /><br />• Ⅷ 优化与重构POM<br />1. pom的清理：提取兄弟项目共同的依赖和配置点<br />2. <span style="color:#f30404;">优化依赖</span>(<span style="color:#f30404;">dependencyManagement的使用</span>)<br />☐ 在多个模块中被声明，或者某个依赖在多个模块被exclude排除； 需要在父POM中巩固版本和依赖声明<br />☐ 依赖是关联的，多个模块共享相同的版本，叫做<span style="color:#f30404;">兄弟依赖，现在还是没搞明白</span>； <br />总结一下我们为了降低依赖重复而完成的<span style="color:#f30404;background-color:#f9f720;">两项优化</span>：<br />☐ 上移共同的依赖至dependencyManagement<br />☐ 为兄弟项目使用内置的项目version和groupId(不懂)<br />3. <span style="color:#f30404;">优化插件</span>(<span style="color:#f30404;">pluginManagement的使用</span>)<br />4. 使用Maven Dependency插件对依赖进行分析然后优化<br />由于有问题：比如我用了Beanutils，这个工具类是由于我引用了hibernate经传递性依赖进来的，一旦我升级hibernate后，hibernate它不再依赖Beanutils了,那我也跟着完蛋<br />解决方法：Dependency插件能够帮助你发现对于依赖的直接引用，使用<span style="color:#f30404;background-color:#f9f720;">命令mvn dependency:analyze</span> 进行分析是否有传递性依赖，该传递性依赖却在编码中使用了（注，之前我们介绍了浏览依赖：<span style="color:#f30404;">mvn dependency:resolve</span>；<span style="color:#f30404;">mvn dependency:tree</span>）<br /><span style="color:#f30404;">analyze发现了那些未使用，但声明的依赖，下面这种情况我们最好小心地进行移除</span><br /><img src="images\43-4.png" alt="images\43-4.png" /><br /><br /><span style="color:#f30404;">analyze可以发现使用了但是没有声明的依赖，也就是该项目最好自己添加该jar的直接引用</span><br /><img src="images\43-5.png" alt="images\43-5.png" /><br />最后简单的<span style="color:#f30404;">修复手段</span>是添加对这个依赖的直接引用<br /><br />提出问题：兄弟依赖是啥？为什么要这么解决？0.6-SNAPSHOT??<br /><br />第二部分是项目实战<br />1.从如何创建一个简单的maven javase项目（archetype<strong><span style="color:#ff9d00;">:</span></strong><strong>generate </strong>, 参数为maven坐标）&amp; 简单的javaweb 项目DarchetypeArtifactId=webapp &amp; maven多模块项目<br />然后引出了如下一些概念：<br />maven的插件（插件名:插件目标，maven把所有工作委托给了maven插件）；<br />maven的生命周期（clean、package、install）,在不同的项目中，使用Maven的接口是一样的，这样就不用去仔细理解每个项目的构建了，我认为这就是约定优于配置的表现，一个Maven生命周期阶段，每个<span style="color:#f30404;">阶段可能绑定了零个或者多个插件目标</span>；<br />maven的坐标与仓库，这些坐标的位置指向的就是该文件在仓库中的地址，仓库<span style="color:#f30404;">可以理解为一个存储文件的文件系统</span>；本地&lt;localRepository&gt;/home/java-dev/.m2/repository&lt;/localRepository&gt; &amp; 三方&lt;repositories&gt; &amp; 远程<br />maven的依赖&amp;如何优化依赖：<br />    比如webull-pom:作用就是提取所有项目的公共dependency并通过dependencyManagement进行管理，下级有谁需要就声明&lt;groupId&gt;和&lt;artifactId&gt;<br /><br />    首先得只要有哪些依赖，所以-&gt;浏览依赖：<span style="color:#f30404;">mvn dependency:resolve</span><br /><br /><span style="color:#f30404;">----------------------------------------------------------------    分割线，3-8章是maven实战性工作      ------------------------------------------------</span><br /><br /><br />spring:<br />• Ⅰ 框架概述<br />1. IoC and DI<br />2. core module<br />3. 使用场景<br /><br />• Ⅱ新功能介绍<br /><br />• Ⅲ核心技术<br />1. IoC<br />2. resources<br />3. Validation, Data Binding, and 类型转换<br />4. Spring 表达式语言 SpEL<br />5. AOP<br />6. Spring AOP api<br />7. Spring Test<br /><br />• Ⅳ数据访问<br />• Ⅴ Web<br />• Ⅵ 整合<br />• Ⅶ 附录</div></div>
</body></html>